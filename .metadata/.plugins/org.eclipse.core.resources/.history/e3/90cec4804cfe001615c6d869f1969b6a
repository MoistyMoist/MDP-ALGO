package com.sg.ntu.mdp.communication;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.sg.ntu.mdp.Algothrim;
import com.sg.ntu.mdp.Direction;
import com.sg.ntu.mdp.RobotCallback;
import com.sg.ntu.mdp.simulator.MapUI;
import com.sg.ntu.mdp.simulator.MoveRobotForwardThread;
import com.sg.ntu.mdp.simulator.TurnRobotThread;

//communication between the robot and algo outputting json
public class AlgoContoller {
	
	static Algothrim algothrim = new Algothrim(null,null,18,2); 
	static RobotCallback callback;
	static boolean isExplorin=true;
	static boolean isReturning=false;
	
	
	
	public AlgoContoller (){
		
	}
	
	public static void returnToStart(int inputLeftSensor, int inputRightSensor, int inputFrontMidSensor, int inputFrontLeftSensor, int inputFrontRightSensor){
		ArrayList<String> jsonInstruction = new ArrayList<String>();
		algothrim.returnToStart(new RobotCallback(){
			@Override
			public void moveForward(int distance) {
				jsonInstruction.add(wrapMoveForwardChangeJson(distance));
			}
			@Override
			public void changeDirection(Direction direction, int times) {
				jsonInstruction.add(wrapDirectionChangeJson(direction,times));
			}
			@Override
			public void readyForFastestPath(){
			}
			@Override
			public void sendRobotInstruction(String jsonInstructions){
				sendRobotInstructions(jsonInstruction);
			}
		});
		
	}
	
	public static void computeFastestPath(){
		ArrayList<String> jsonInstruction = new ArrayList<String>();
		
		algothrim.findPath(new RobotCallback(){
			@Override
			public void moveForward(int distance) {
				jsonInstruction.add(wrapMoveForwardChangeJson(distance));
			}
			@Override
			public void changeDirection(Direction direction, int times) {
				jsonInstruction.add(wrapDirectionChangeJson(direction,times));
			}
			@Override
			public void readyForFastestPath(){
				sendRobotInstructions(jsonInstruction);
			}	
			@Override
			public void sendRobotInstruction(String jsonInstructions){
			}
		});
	}
	
	public static void explore(int inputLeftSensor, int inputRightSensor, int inputFrontMidSensor, int inputFrontLeftSensor, int inputFrontRightSensor){
		ArrayList<String> jsonInstruction = new ArrayList<String>();
		
		algothrim.exploreSimulation(inputFrontMidSensor, inputFrontLeftSensor, inputFrontRightSensor, inputRightSensor, inputLeftSensor, new RobotCallback(){
			@Override
			public void moveForward(int distance) {
				System.out.println("moving for");
				jsonInstruction.add(wrapMoveForwardChangeJson(distance));
			}
			@Override
			public void changeDirection(Direction direction, int times) {
				
				jsonInstruction.add(wrapDirectionChangeJson(direction,times));
			}
			@Override
			public void readyForFastestPath(){
			}
			@Override
			public void sendRobotInstruction(String jsonInstructions){
				sendRobotInstructions(jsonInstruction);
			}
		});
		
		
	}
	
	public static void parseMessageFromRobot(String json, RobotCallback inCallback){
		callback=inCallback;
		String message=json.replace("{", "");
		message=message.replace("}", "");
		List<String> sensorList = Arrays.asList(message.split(","));
		for(int i=0;i<sensorList.size();i++){
			System.out.println("received "+sensorList.get(i));
		}
		
		if(isExplorin==true){
			explore(Integer.parseInt(sensorList.get(0)),Integer.parseInt(sensorList.get(1)),Integer.parseInt(sensorList.get(2)),Integer.parseInt(sensorList.get(3)),Integer.parseInt(sensorList.get(4)));
		}else if(isReturning==true){
			returnToStart(Integer.parseInt(sensorList.get(0)),Integer.parseInt(sensorList.get(1)),Integer.parseInt(sensorList.get(2)),Integer.parseInt(sensorList.get(3)),Integer.parseInt(sensorList.get(4)));
		}else{
			computeFastestPath();
		}
		
	}
	
	public static void sendRobotInstructions(ArrayList<String> jsonInstructions){
		String jsonInstructionsWraper="[";
		for(int i=0;i<jsonInstructions.size();i++){
			jsonInstructionsWraper+=jsonInstructions.get(i);
			if((i+1)!=jsonInstructions.size()){
				jsonInstructionsWraper+=",";
			}
		}
		
		jsonInstructionsWraper+="]";
		System.out.println("jsonInstructionsWraper");
		callback.sendRobotInstruction(jsonInstructionsWraper);
	}
	public static String wrapDirectionChangeJson(Direction direction, int times){
		String jsonString="{";
		jsonString +="InstructionType=DirectionChange,"+direction.toString()+","+times+";";
		
		return jsonString+="}";
	}
	public static String wrapMoveForwardChangeJson(int times){
		String jsonString="{";
		jsonString +="InstructionType=MoveForward,"+times+";";
		return jsonString+="}";
	}

	public static void updateRobotUI(Direction direction, int times,boolean isForward){
		System.out.println("CURRENT ROW IS "+Algothrim.currentLocationFrontRow);
		if(isForward==true){
			moveRobotUIForward(times);
		}
		
	}
	
	public static void moveRobotUIForward(int distance){
		MapUI.mapPanel.remove(MapUI.robotHead);
    	MapUI.mapPanel.remove(MapUI.robotBody);
		switch(Algothrim.currentDirection){
			case North:
				MapUI.robotHeadConstrain.gridx = MapUI.robotHeadConstrain.gridx+distance;
				MapUI.robotHeadConstrain.gridy = MapUI.robotHeadConstrain.gridy;
				MapUI.robotBodyConstrain.gridx = MapUI.robotBodyConstrain.gridx+distance;
				MapUI.robotBodyConstrain.gridy = MapUI.robotBodyConstrain.gridy;
				
				Algothrim.currentLocationFrontRow=Algothrim.currentLocationFrontRow-1;
				break;
			case South:
				MapUI.robotHeadConstrain.gridx = MapUI.robotHeadConstrain.gridx-distance;
				MapUI.robotHeadConstrain.gridy = MapUI.robotHeadConstrain.gridy;
				MapUI.robotBodyConstrain.gridx = MapUI.robotBodyConstrain.gridx-distance;
				MapUI.robotBodyConstrain.gridy = MapUI.robotBodyConstrain.gridy;
				
				Algothrim.currentLocationFrontRow=Algothrim.currentLocationFrontRow+1;
				break;
			case East:
				MapUI.robotHeadConstrain.gridx = MapUI.robotHeadConstrain.gridx;
				MapUI.robotHeadConstrain.gridy = MapUI.robotHeadConstrain.gridy+distance;
				MapUI.robotBodyConstrain.gridx = MapUI.robotBodyConstrain.gridx;
				MapUI.robotBodyConstrain.gridy = MapUI.robotBodyConstrain.gridy+distance;
				
				Algothrim.currentLocationFrontCol=Algothrim.currentLocationFrontCol+1;
				break;
			case West:
				MapUI.robotHeadConstrain.gridx = MapUI.robotHeadConstrain.gridx;
				MapUI.robotHeadConstrain.gridy = MapUI.robotHeadConstrain.gridy-distance;
				MapUI.robotBodyConstrain.gridx = MapUI.robotBodyConstrain.gridx;
				MapUI.robotBodyConstrain.gridy = MapUI.robotBodyConstrain.gridy-distance;
				
				Algothrim.currentLocationFrontCol=Algothrim.currentLocationFrontCol-1;
				break;
		}
//		System.out.println("CUrrent row = "+Algothrim.currentLocationFrontRow);
//		System.out.println("CUrrent COl = "+Algothrim.currentLocationFrontCol);
	
		
		MapUI.labels[MapUI.robotBodyConstrain.gridx+1][MapUI.robotBodyConstrain.gridy].setText("1");
		MapUI.labels[MapUI.robotBodyConstrain.gridx-1][MapUI.robotBodyConstrain.gridy].setText("1");
		MapUI.labels[MapUI.robotBodyConstrain.gridx][MapUI.robotBodyConstrain.gridy+1].setText("1");
		MapUI.labels[MapUI.robotBodyConstrain.gridx+1][MapUI.robotBodyConstrain.gridy+1].setText("1");
		MapUI.labels[MapUI.robotBodyConstrain.gridx-1][MapUI.robotBodyConstrain.gridy+1].setText("1");
		MapUI.labels[MapUI.robotBodyConstrain.gridx][MapUI.robotBodyConstrain.gridy-1].setText("1");
		MapUI.labels[MapUI.robotBodyConstrain.gridx+1][MapUI.robotBodyConstrain.gridy-1].setText("1");
		MapUI.labels[MapUI.robotBodyConstrain.gridx-1][MapUI.robotBodyConstrain.gridy-1].setText("1");

		Algothrim.exploredData=MapUI.saveExploredData(MapUI.labels);
		
		MapUI.mapPanel.add(MapUI.robotHead, MapUI.robotHeadConstrain,1);
		MapUI.mapPanel.add(MapUI.robotBody, MapUI.robotBodyConstrain,2);
		MapUI.mapPanel.repaint();
		MapUI.mapPanel.revalidate();
    	notify();
	}
}
