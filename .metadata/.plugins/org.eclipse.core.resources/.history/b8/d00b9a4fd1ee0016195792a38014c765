package com.sg.ntu.mdp;

public class Algothrim {
	private float frontMidSensor;
	private float frontLeftSensor;
	private float frontRightSensor;
	private float rightSensor;
	private float leftSensor5;
	
	private Direction currentDirection = Direction.East;
	private float sensorTrashold = 4.00f;
	
	private static int[][]exploredData;
	private static int[][]obstacleData;
	private static int[][]currentLocation;
	
	private Algothrim(int[][] exploredData, int[][]obstacleData, int[][] currentLocation){
		this.exploredData = exploredData;
		this.obstacleData = obstacleData;
		if(currentLocation != null){
			this.currentLocation = currentLocation;
		}
	}
	
	private void explore(float frontMidSensor, float frontLeftSensor, float frontRightSensor, float rightSensor, float leftSensor, final RobotCallback callback){
		//TODO: algo to moce the next move
		if(leftSensor<=sensorTrashold){
			//obstacle on robot left
			//update the obstacle data
			switch(currentDirection){
				case North:
					break;
				case South:
					break;
				case East:
					break;
				case West:
					break;
			}
		}
		if(rightSensor<=sensorTrashold){
			//obstacle on robot right
			//update the obstacle data
			switch(currentDirection){
				case North:
					break;
				case South:
					break;
				case East:
					break;
				case West:
					break;
			}
		}
		
		
		if(currentDirection == Direction.East){
			
			if(frontMidSensor>sensorTrashold && frontRightSensor>sensorTrashold && frontLeftSensor>sensorTrashold){
				//nothing infront move forward
			}
			
		}
	}
	
	private void returnToStart(){
		//TODO: algo to make the robot go back to start line;
	}
	
	private void findPath(int[][] currentLocation){
		//TODO: get the shortest path;
	}
	
	
}
